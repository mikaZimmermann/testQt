/* soapStub.h
   Generated by gSOAP 2.8.124 for gmafHeader

gSOAP XML Web services tools
Copyright (C) 2000-2022, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://api.gmaf.swa.de/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208124
# error "GSOAP VERSION 208124 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* gmafHeader:151 */
class ns1__processAssetFromURL;	/* gmafHeader:169 */
class ns1__processAssetFromURLResponse;	/* gmafHeader:171 */
class ns1__mmfg;	/* gmafHeader:173 */
class ns1__node;	/* gmafHeader:175 */
class ns1__generalMetadata;	/* gmafHeader:177 */
class ns1__security;	/* gmafHeader:179 */
class ns1__getOrGenerateGraphCode;	/* gmafHeader:181 */
class ns1__getOrGenerateGraphCodeResponse;	/* gmafHeader:183 */
class ns1__graphCode;	/* gmafHeader:185 */
class ns1__getSimilarAssets;	/* gmafHeader:187 */
class ns1__getSimilarAssetsResponse;	/* gmafHeader:189 */
class ns1__getRecommendedAssets;	/* gmafHeader:191 */
class ns1__getRecommendedAssetsResponse;	/* gmafHeader:193 */
class ns1__getAuthToken;	/* gmafHeader:195 */
class ns1__getAuthTokenResponse;	/* gmafHeader:197 */
class ns1__processAssetFromBytes;	/* gmafHeader:199 */
class ns1__processAssetFromBytesResponse;	/* gmafHeader:201 */
class ns1__setProcessingPlugins;	/* gmafHeader:203 */
class ns1__setProcessingPluginsResponse;	/* gmafHeader:205 */
class ns1__processAssetFromFile;	/* gmafHeader:207 */
class ns1__processAssetFromFileResponse;	/* gmafHeader:209 */
class ns1__getCollection;	/* gmafHeader:211 */
class ns1__getCollectionResponse;	/* gmafHeader:213 */
struct __ns1__getAuthToken;	/* gmafHeader:1017 */
struct __ns1__getCollection;	/* gmafHeader:1084 */
struct __ns1__processAssetFromFile;	/* gmafHeader:1151 */
struct __ns1__processAssetFromBytes;	/* gmafHeader:1218 */
struct __ns1__processAssetFromURL;	/* gmafHeader:1285 */
struct __ns1__getOrGenerateGraphCode;	/* gmafHeader:1352 */
struct __ns1__setProcessingPlugins;	/* gmafHeader:1419 */
struct __ns1__getRecommendedAssets;	/* gmafHeader:1486 */
struct __ns1__getSimilarAssets;	/* gmafHeader:1553 */

/* gmafHeader:151 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        /// Destructor
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:169 */
#ifndef SOAP_TYPE_ns1__processAssetFromURL
#define SOAP_TYPE_ns1__processAssetFromURL (14)
/* complex XML schema type 'ns1:processAssetFromURL': */
class SOAP_CMAC ns1__processAssetFromURL {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:anyURI'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__processAssetFromURL
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__processAssetFromURL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__processAssetFromURL, default initialized and not managed by a soap context
        virtual ns1__processAssetFromURL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__processAssetFromURL); }
      public:
        /// Constructor with default initializations
        ns1__processAssetFromURL() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns1__processAssetFromURL() { }
        /// Friend allocator used by soap_new_ns1__processAssetFromURL(struct soap*, int)
        friend SOAP_FMAC1 ns1__processAssetFromURL * SOAP_FMAC2 soap_instantiate_ns1__processAssetFromURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:171 */
#ifndef SOAP_TYPE_ns1__processAssetFromURLResponse
#define SOAP_TYPE_ns1__processAssetFromURLResponse (15)
/* complex XML schema type 'ns1:processAssetFromURLResponse': */
class SOAP_CMAC ns1__processAssetFromURLResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns1:mmfg'
        ns1__mmfg *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__processAssetFromURLResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__processAssetFromURLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__processAssetFromURLResponse, default initialized and not managed by a soap context
        virtual ns1__processAssetFromURLResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__processAssetFromURLResponse); }
      public:
        /// Constructor with default initializations
        ns1__processAssetFromURLResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__processAssetFromURLResponse() { }
        /// Friend allocator used by soap_new_ns1__processAssetFromURLResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__processAssetFromURLResponse * SOAP_FMAC2 soap_instantiate_ns1__processAssetFromURLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:173 */
#ifndef SOAP_TYPE_ns1__mmfg
#define SOAP_TYPE_ns1__mmfg (16)
/* complex XML schema type 'ns1:mmfg': */
class SOAP_CMAC ns1__mmfg {
      public:
        /// Optional element 'allNodes' of XML schema type 'ns1:node'
        std::vector<ns1__node *> allNodes;
        /// Optional element 'currentNode' of XML schema type 'ns1:node'
        ns1__node *currentNode;
        /// Optional element 'generalMetadata' of XML schema type 'ns1:generalMetadata'
        ns1__generalMetadata *generalMetadata;
        /// Optional element 'security' of XML schema type 'ns1:security'
        ns1__security *security;
        /// Optional element 'similarity' of XML schema type 'xsd:float'
        std::vector<float> similarity;
        /// Optional element 'tempSimilarity' of XML schema type 'xsd:float'
        std::vector<float> tempSimilarity;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__mmfg
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__mmfg; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__mmfg, default initialized and not managed by a soap context
        virtual ns1__mmfg *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__mmfg); }
      public:
        /// Constructor with default initializations
        ns1__mmfg() : allNodes(), currentNode(), generalMetadata(), security(), similarity(), tempSimilarity(), soap() { }
        /// Destructor
        virtual ~ns1__mmfg() { }
        /// Friend allocator used by soap_new_ns1__mmfg(struct soap*, int)
        friend SOAP_FMAC1 ns1__mmfg * SOAP_FMAC2 soap_instantiate_ns1__mmfg(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:175 */
#ifndef SOAP_TYPE_ns1__node
#define SOAP_TYPE_ns1__node (17)
/* complex XML schema type 'ns1:node': */
class SOAP_CMAC ns1__node {
      public:
        /// Optional element 'detectedBy' of XML schema type 'xsd:string'
        std::string *detectedBy;
        /// Optional element 'name' of XML schema type 'xsd:string'
        std::string *name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__node
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__node; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__node, default initialized and not managed by a soap context
        virtual ns1__node *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__node); }
      public:
        /// Constructor with default initializations
        ns1__node() : detectedBy(), name(), soap() { }
        /// Destructor
        virtual ~ns1__node() { }
        /// Friend allocator used by soap_new_ns1__node(struct soap*, int)
        friend SOAP_FMAC1 ns1__node * SOAP_FMAC2 soap_instantiate_ns1__node(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:177 */
#ifndef SOAP_TYPE_ns1__generalMetadata
#define SOAP_TYPE_ns1__generalMetadata (18)
/* complex XML schema type 'ns1:generalMetadata': */
class SOAP_CMAC ns1__generalMetadata {
      public:
        /// Required element 'aperture' of XML schema type 'xsd:float'
        float aperture;
        /// Optional element 'cameraModel' of XML schema type 'xsd:string'
        std::string *cameraModel;
        /// Optional element 'cityNearBy' of XML schema type 'xsd:string'
        std::string *cityNearBy;
        /// Optional element 'date' of XML schema type 'xsd:dateTime'
        time_t *date;
        /// Required element 'exposure' of XML schema type 'xsd:float'
        float exposure;
        /// Optional element 'fileName' of XML schema type 'xsd:string'
        std::string *fileName;
        /// Optional element 'fileReference' of XML schema type 'xsd:string'
        std::string *fileReference;
        /// Required element 'fileSize' of XML schema type 'xsd:long'
        LONG64 fileSize;
        /// Required element 'focalLength' of XML schema type 'xsd:long'
        LONG64 focalLength;
        /// Required element 'height' of XML schema type 'xsd:int'
        int height;
        /// Optional element 'id' of XML schema type 'xsd:string'
        std::string *id;
        /// Required element 'iso' of XML schema type 'xsd:int'
        int iso;
        /// Required element 'latitude' of XML schema type 'xsd:long'
        LONG64 latitude;
        /// Optional element 'lensModel' of XML schema type 'xsd:string'
        std::string *lensModel;
        /// Required element 'longitude' of XML schema type 'xsd:long'
        LONG64 longitude;
        /// Required element 'resolution' of XML schema type 'xsd:int'
        int resolution;
        /// Required element 'shutterSpeed' of XML schema type 'xsd:long'
        LONG64 shutterSpeed;
        /// Required element 'width' of XML schema type 'xsd:int'
        int width;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__generalMetadata
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__generalMetadata; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__generalMetadata, default initialized and not managed by a soap context
        virtual ns1__generalMetadata *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__generalMetadata); }
      public:
        /// Constructor with default initializations
        ns1__generalMetadata() : aperture(), cameraModel(), cityNearBy(), date(), exposure(), fileName(), fileReference(), fileSize(), focalLength(), height(), id(), iso(), latitude(), lensModel(), longitude(), resolution(), shutterSpeed(), width(), soap() { }
        /// Destructor
        virtual ~ns1__generalMetadata() { }
        /// Friend allocator used by soap_new_ns1__generalMetadata(struct soap*, int)
        friend SOAP_FMAC1 ns1__generalMetadata * SOAP_FMAC2 soap_instantiate_ns1__generalMetadata(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:179 */
#ifndef SOAP_TYPE_ns1__security
#define SOAP_TYPE_ns1__security (19)
/* complex XML schema type 'ns1:security': */
class SOAP_CMAC ns1__security {
      public:
        /// Optional element 'acl' of XML schema type 'xsd:string'
        std::string *acl;
        /// Optional element 'group_id' of XML schema type 'xsd:string'
        std::string *group_USCOREid;
        /// Optional element 'owner_id' of XML schema type 'xsd:string'
        std::string *owner_USCOREid;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__security
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__security; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__security, default initialized and not managed by a soap context
        virtual ns1__security *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__security); }
      public:
        /// Constructor with default initializations
        ns1__security() : acl(), group_USCOREid(), owner_USCOREid(), soap() { }
        /// Destructor
        virtual ~ns1__security() { }
        /// Friend allocator used by soap_new_ns1__security(struct soap*, int)
        friend SOAP_FMAC1 ns1__security * SOAP_FMAC2 soap_instantiate_ns1__security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:181 */
#ifndef SOAP_TYPE_ns1__getOrGenerateGraphCode
#define SOAP_TYPE_ns1__getOrGenerateGraphCode (20)
/* complex XML schema type 'ns1:getOrGenerateGraphCode': */
class SOAP_CMAC ns1__getOrGenerateGraphCode {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'ns1:mmfg'
        ns1__mmfg *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getOrGenerateGraphCode
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getOrGenerateGraphCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getOrGenerateGraphCode, default initialized and not managed by a soap context
        virtual ns1__getOrGenerateGraphCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getOrGenerateGraphCode); }
      public:
        /// Constructor with default initializations
        ns1__getOrGenerateGraphCode() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns1__getOrGenerateGraphCode() { }
        /// Friend allocator used by soap_new_ns1__getOrGenerateGraphCode(struct soap*, int)
        friend SOAP_FMAC1 ns1__getOrGenerateGraphCode * SOAP_FMAC2 soap_instantiate_ns1__getOrGenerateGraphCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:183 */
#ifndef SOAP_TYPE_ns1__getOrGenerateGraphCodeResponse
#define SOAP_TYPE_ns1__getOrGenerateGraphCodeResponse (21)
/* complex XML schema type 'ns1:getOrGenerateGraphCodeResponse': */
class SOAP_CMAC ns1__getOrGenerateGraphCodeResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns1:graphCode'
        ns1__graphCode *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getOrGenerateGraphCodeResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getOrGenerateGraphCodeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getOrGenerateGraphCodeResponse, default initialized and not managed by a soap context
        virtual ns1__getOrGenerateGraphCodeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getOrGenerateGraphCodeResponse); }
      public:
        /// Constructor with default initializations
        ns1__getOrGenerateGraphCodeResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__getOrGenerateGraphCodeResponse() { }
        /// Friend allocator used by soap_new_ns1__getOrGenerateGraphCodeResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getOrGenerateGraphCodeResponse * SOAP_FMAC2 soap_instantiate_ns1__getOrGenerateGraphCodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:185 */
#ifndef SOAP_TYPE_ns1__graphCode
#define SOAP_TYPE_ns1__graphCode (22)
/* complex XML schema type 'ns1:graphCode': */
class SOAP_CMAC ns1__graphCode {
      public:
        /// Optional element 'dictionary' of XML schema type 'xsd:string'
        std::vector<std::string> dictionary;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__graphCode
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__graphCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__graphCode, default initialized and not managed by a soap context
        virtual ns1__graphCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__graphCode); }
      public:
        /// Constructor with default initializations
        ns1__graphCode() : dictionary(), soap() { }
        /// Destructor
        virtual ~ns1__graphCode() { }
        /// Friend allocator used by soap_new_ns1__graphCode(struct soap*, int)
        friend SOAP_FMAC1 ns1__graphCode * SOAP_FMAC2 soap_instantiate_ns1__graphCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:187 */
#ifndef SOAP_TYPE_ns1__getSimilarAssets
#define SOAP_TYPE_ns1__getSimilarAssets (23)
/* complex XML schema type 'ns1:getSimilarAssets': */
class SOAP_CMAC ns1__getSimilarAssets {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'ns1:graphCode'
        ns1__graphCode *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getSimilarAssets
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getSimilarAssets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getSimilarAssets, default initialized and not managed by a soap context
        virtual ns1__getSimilarAssets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getSimilarAssets); }
      public:
        /// Constructor with default initializations
        ns1__getSimilarAssets() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns1__getSimilarAssets() { }
        /// Friend allocator used by soap_new_ns1__getSimilarAssets(struct soap*, int)
        friend SOAP_FMAC1 ns1__getSimilarAssets * SOAP_FMAC2 soap_instantiate_ns1__getSimilarAssets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:189 */
#ifndef SOAP_TYPE_ns1__getSimilarAssetsResponse
#define SOAP_TYPE_ns1__getSimilarAssetsResponse (24)
/* complex XML schema type 'ns1:getSimilarAssetsResponse': */
class SOAP_CMAC ns1__getSimilarAssetsResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns1:mmfg'
        std::vector<ns1__mmfg *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getSimilarAssetsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getSimilarAssetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getSimilarAssetsResponse, default initialized and not managed by a soap context
        virtual ns1__getSimilarAssetsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getSimilarAssetsResponse); }
      public:
        /// Constructor with default initializations
        ns1__getSimilarAssetsResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__getSimilarAssetsResponse() { }
        /// Friend allocator used by soap_new_ns1__getSimilarAssetsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getSimilarAssetsResponse * SOAP_FMAC2 soap_instantiate_ns1__getSimilarAssetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:191 */
#ifndef SOAP_TYPE_ns1__getRecommendedAssets
#define SOAP_TYPE_ns1__getRecommendedAssets (25)
/* complex XML schema type 'ns1:getRecommendedAssets': */
class SOAP_CMAC ns1__getRecommendedAssets {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'ns1:graphCode'
        ns1__graphCode *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getRecommendedAssets
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getRecommendedAssets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getRecommendedAssets, default initialized and not managed by a soap context
        virtual ns1__getRecommendedAssets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getRecommendedAssets); }
      public:
        /// Constructor with default initializations
        ns1__getRecommendedAssets() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns1__getRecommendedAssets() { }
        /// Friend allocator used by soap_new_ns1__getRecommendedAssets(struct soap*, int)
        friend SOAP_FMAC1 ns1__getRecommendedAssets * SOAP_FMAC2 soap_instantiate_ns1__getRecommendedAssets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:193 */
#ifndef SOAP_TYPE_ns1__getRecommendedAssetsResponse
#define SOAP_TYPE_ns1__getRecommendedAssetsResponse (26)
/* complex XML schema type 'ns1:getRecommendedAssetsResponse': */
class SOAP_CMAC ns1__getRecommendedAssetsResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns1:mmfg'
        std::vector<ns1__mmfg *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getRecommendedAssetsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getRecommendedAssetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getRecommendedAssetsResponse, default initialized and not managed by a soap context
        virtual ns1__getRecommendedAssetsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getRecommendedAssetsResponse); }
      public:
        /// Constructor with default initializations
        ns1__getRecommendedAssetsResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__getRecommendedAssetsResponse() { }
        /// Friend allocator used by soap_new_ns1__getRecommendedAssetsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getRecommendedAssetsResponse * SOAP_FMAC2 soap_instantiate_ns1__getRecommendedAssetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:195 */
#ifndef SOAP_TYPE_ns1__getAuthToken
#define SOAP_TYPE_ns1__getAuthToken (27)
/* complex XML schema type 'ns1:getAuthToken': */
class SOAP_CMAC ns1__getAuthToken {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getAuthToken
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getAuthToken; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getAuthToken, default initialized and not managed by a soap context
        virtual ns1__getAuthToken *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getAuthToken); }
      public:
        /// Constructor with default initializations
        ns1__getAuthToken() : arg0(), soap() { }
        /// Destructor
        virtual ~ns1__getAuthToken() { }
        /// Friend allocator used by soap_new_ns1__getAuthToken(struct soap*, int)
        friend SOAP_FMAC1 ns1__getAuthToken * SOAP_FMAC2 soap_instantiate_ns1__getAuthToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:197 */
#ifndef SOAP_TYPE_ns1__getAuthTokenResponse
#define SOAP_TYPE_ns1__getAuthTokenResponse (28)
/* complex XML schema type 'ns1:getAuthTokenResponse': */
class SOAP_CMAC ns1__getAuthTokenResponse {
      public:
        /// Optional element 'return' of XML schema type 'xsd:string'
        std::string *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getAuthTokenResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getAuthTokenResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getAuthTokenResponse, default initialized and not managed by a soap context
        virtual ns1__getAuthTokenResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getAuthTokenResponse); }
      public:
        /// Constructor with default initializations
        ns1__getAuthTokenResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__getAuthTokenResponse() { }
        /// Friend allocator used by soap_new_ns1__getAuthTokenResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getAuthTokenResponse * SOAP_FMAC2 soap_instantiate_ns1__getAuthTokenResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:199 */
#ifndef SOAP_TYPE_ns1__processAssetFromBytes
#define SOAP_TYPE_ns1__processAssetFromBytes (29)
/* complex XML schema type 'ns1:processAssetFromBytes': */
class SOAP_CMAC ns1__processAssetFromBytes {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary *arg1;
        /// Optional element 'arg2' of XML schema type 'xsd:string'
        std::string *arg2;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__processAssetFromBytes
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__processAssetFromBytes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__processAssetFromBytes, default initialized and not managed by a soap context
        virtual ns1__processAssetFromBytes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__processAssetFromBytes); }
      public:
        /// Constructor with default initializations
        ns1__processAssetFromBytes() : arg0(), arg1(), arg2(), soap() { }
        /// Destructor
        virtual ~ns1__processAssetFromBytes() { }
        /// Friend allocator used by soap_new_ns1__processAssetFromBytes(struct soap*, int)
        friend SOAP_FMAC1 ns1__processAssetFromBytes * SOAP_FMAC2 soap_instantiate_ns1__processAssetFromBytes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:201 */
#ifndef SOAP_TYPE_ns1__processAssetFromBytesResponse
#define SOAP_TYPE_ns1__processAssetFromBytesResponse (30)
/* complex XML schema type 'ns1:processAssetFromBytesResponse': */
class SOAP_CMAC ns1__processAssetFromBytesResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns1:mmfg'
        ns1__mmfg *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__processAssetFromBytesResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__processAssetFromBytesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__processAssetFromBytesResponse, default initialized and not managed by a soap context
        virtual ns1__processAssetFromBytesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__processAssetFromBytesResponse); }
      public:
        /// Constructor with default initializations
        ns1__processAssetFromBytesResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__processAssetFromBytesResponse() { }
        /// Friend allocator used by soap_new_ns1__processAssetFromBytesResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__processAssetFromBytesResponse * SOAP_FMAC2 soap_instantiate_ns1__processAssetFromBytesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:203 */
#ifndef SOAP_TYPE_ns1__setProcessingPlugins
#define SOAP_TYPE_ns1__setProcessingPlugins (31)
/* complex XML schema type 'ns1:setProcessingPlugins': */
class SOAP_CMAC ns1__setProcessingPlugins {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::vector<std::string> arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__setProcessingPlugins
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__setProcessingPlugins; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__setProcessingPlugins, default initialized and not managed by a soap context
        virtual ns1__setProcessingPlugins *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__setProcessingPlugins); }
      public:
        /// Constructor with default initializations
        ns1__setProcessingPlugins() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns1__setProcessingPlugins() { }
        /// Friend allocator used by soap_new_ns1__setProcessingPlugins(struct soap*, int)
        friend SOAP_FMAC1 ns1__setProcessingPlugins * SOAP_FMAC2 soap_instantiate_ns1__setProcessingPlugins(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:205 */
#ifndef SOAP_TYPE_ns1__setProcessingPluginsResponse
#define SOAP_TYPE_ns1__setProcessingPluginsResponse (32)
/* complex XML schema type 'ns1:setProcessingPluginsResponse': */
class SOAP_CMAC ns1__setProcessingPluginsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__setProcessingPluginsResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__setProcessingPluginsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__setProcessingPluginsResponse, default initialized and not managed by a soap context
        virtual ns1__setProcessingPluginsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__setProcessingPluginsResponse); }
      public:
        /// Constructor with default initializations
        ns1__setProcessingPluginsResponse() : soap() { }
        /// Destructor
        virtual ~ns1__setProcessingPluginsResponse() { }
        /// Friend allocator used by soap_new_ns1__setProcessingPluginsResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__setProcessingPluginsResponse * SOAP_FMAC2 soap_instantiate_ns1__setProcessingPluginsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:207 */
#ifndef SOAP_TYPE_ns1__processAssetFromFile
#define SOAP_TYPE_ns1__processAssetFromFile (33)
/* complex XML schema type 'ns1:processAssetFromFile': */
class SOAP_CMAC ns1__processAssetFromFile {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Optional element 'arg1' of XML schema type 'xsd:string'
        std::string *arg1;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__processAssetFromFile
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__processAssetFromFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__processAssetFromFile, default initialized and not managed by a soap context
        virtual ns1__processAssetFromFile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__processAssetFromFile); }
      public:
        /// Constructor with default initializations
        ns1__processAssetFromFile() : arg0(), arg1(), soap() { }
        /// Destructor
        virtual ~ns1__processAssetFromFile() { }
        /// Friend allocator used by soap_new_ns1__processAssetFromFile(struct soap*, int)
        friend SOAP_FMAC1 ns1__processAssetFromFile * SOAP_FMAC2 soap_instantiate_ns1__processAssetFromFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:209 */
#ifndef SOAP_TYPE_ns1__processAssetFromFileResponse
#define SOAP_TYPE_ns1__processAssetFromFileResponse (34)
/* complex XML schema type 'ns1:processAssetFromFileResponse': */
class SOAP_CMAC ns1__processAssetFromFileResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns1:mmfg'
        ns1__mmfg *return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__processAssetFromFileResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__processAssetFromFileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__processAssetFromFileResponse, default initialized and not managed by a soap context
        virtual ns1__processAssetFromFileResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__processAssetFromFileResponse); }
      public:
        /// Constructor with default initializations
        ns1__processAssetFromFileResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__processAssetFromFileResponse() { }
        /// Friend allocator used by soap_new_ns1__processAssetFromFileResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__processAssetFromFileResponse * SOAP_FMAC2 soap_instantiate_ns1__processAssetFromFileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:211 */
#ifndef SOAP_TYPE_ns1__getCollection
#define SOAP_TYPE_ns1__getCollection (35)
/* complex XML schema type 'ns1:getCollection': */
class SOAP_CMAC ns1__getCollection {
      public:
        /// Optional element 'arg0' of XML schema type 'xsd:string'
        std::string *arg0;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getCollection
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getCollection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getCollection, default initialized and not managed by a soap context
        virtual ns1__getCollection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getCollection); }
      public:
        /// Constructor with default initializations
        ns1__getCollection() : arg0(), soap() { }
        /// Destructor
        virtual ~ns1__getCollection() { }
        /// Friend allocator used by soap_new_ns1__getCollection(struct soap*, int)
        friend SOAP_FMAC1 ns1__getCollection * SOAP_FMAC2 soap_instantiate_ns1__getCollection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:213 */
#ifndef SOAP_TYPE_ns1__getCollectionResponse
#define SOAP_TYPE_ns1__getCollectionResponse (36)
/* complex XML schema type 'ns1:getCollectionResponse': */
class SOAP_CMAC ns1__getCollectionResponse {
      public:
        /// Optional element 'return' of XML schema type 'ns1:mmfg'
        std::vector<ns1__mmfg *> return_;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__getCollectionResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__getCollectionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__getCollectionResponse, default initialized and not managed by a soap context
        virtual ns1__getCollectionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__getCollectionResponse); }
      public:
        /// Constructor with default initializations
        ns1__getCollectionResponse() : return_(), soap() { }
        /// Destructor
        virtual ~ns1__getCollectionResponse() { }
        /// Friend allocator used by soap_new_ns1__getCollectionResponse(struct soap*, int)
        friend SOAP_FMAC1 ns1__getCollectionResponse * SOAP_FMAC2 soap_instantiate_ns1__getCollectionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1017 */
#ifndef SOAP_TYPE___ns1__getAuthToken
#define SOAP_TYPE___ns1__getAuthToken (57)
/* Wrapper: */
struct SOAP_CMAC __ns1__getAuthToken {
      public:
        /** Optional element 'ns1:getAuthToken' of XML schema type 'ns1:getAuthToken' */
        ns1__getAuthToken *ns1__getAuthToken_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getAuthToken */
        long soap_type() const { return SOAP_TYPE___ns1__getAuthToken; }
        /** Constructor with member initializations */
        __ns1__getAuthToken() : ns1__getAuthToken_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getAuthToken * SOAP_FMAC2 soap_instantiate___ns1__getAuthToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1084 */
#ifndef SOAP_TYPE___ns1__getCollection
#define SOAP_TYPE___ns1__getCollection (61)
/* Wrapper: */
struct SOAP_CMAC __ns1__getCollection {
      public:
        /** Optional element 'ns1:getCollection' of XML schema type 'ns1:getCollection' */
        ns1__getCollection *ns1__getCollection_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getCollection */
        long soap_type() const { return SOAP_TYPE___ns1__getCollection; }
        /** Constructor with member initializations */
        __ns1__getCollection() : ns1__getCollection_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getCollection * SOAP_FMAC2 soap_instantiate___ns1__getCollection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1151 */
#ifndef SOAP_TYPE___ns1__processAssetFromFile
#define SOAP_TYPE___ns1__processAssetFromFile (65)
/* Wrapper: */
struct SOAP_CMAC __ns1__processAssetFromFile {
      public:
        /** Optional element 'ns1:processAssetFromFile' of XML schema type 'ns1:processAssetFromFile' */
        ns1__processAssetFromFile *ns1__processAssetFromFile_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__processAssetFromFile */
        long soap_type() const { return SOAP_TYPE___ns1__processAssetFromFile; }
        /** Constructor with member initializations */
        __ns1__processAssetFromFile() : ns1__processAssetFromFile_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__processAssetFromFile * SOAP_FMAC2 soap_instantiate___ns1__processAssetFromFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1218 */
#ifndef SOAP_TYPE___ns1__processAssetFromBytes
#define SOAP_TYPE___ns1__processAssetFromBytes (69)
/* Wrapper: */
struct SOAP_CMAC __ns1__processAssetFromBytes {
      public:
        /** Optional element 'ns1:processAssetFromBytes' of XML schema type 'ns1:processAssetFromBytes' */
        ns1__processAssetFromBytes *ns1__processAssetFromBytes_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__processAssetFromBytes */
        long soap_type() const { return SOAP_TYPE___ns1__processAssetFromBytes; }
        /** Constructor with member initializations */
        __ns1__processAssetFromBytes() : ns1__processAssetFromBytes_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__processAssetFromBytes * SOAP_FMAC2 soap_instantiate___ns1__processAssetFromBytes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1285 */
#ifndef SOAP_TYPE___ns1__processAssetFromURL
#define SOAP_TYPE___ns1__processAssetFromURL (73)
/* Wrapper: */
struct SOAP_CMAC __ns1__processAssetFromURL {
      public:
        /** Optional element 'ns1:processAssetFromURL' of XML schema type 'ns1:processAssetFromURL' */
        ns1__processAssetFromURL *ns1__processAssetFromURL_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__processAssetFromURL */
        long soap_type() const { return SOAP_TYPE___ns1__processAssetFromURL; }
        /** Constructor with member initializations */
        __ns1__processAssetFromURL() : ns1__processAssetFromURL_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__processAssetFromURL * SOAP_FMAC2 soap_instantiate___ns1__processAssetFromURL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1352 */
#ifndef SOAP_TYPE___ns1__getOrGenerateGraphCode
#define SOAP_TYPE___ns1__getOrGenerateGraphCode (77)
/* Wrapper: */
struct SOAP_CMAC __ns1__getOrGenerateGraphCode {
      public:
        /** Optional element 'ns1:getOrGenerateGraphCode' of XML schema type 'ns1:getOrGenerateGraphCode' */
        ns1__getOrGenerateGraphCode *ns1__getOrGenerateGraphCode_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getOrGenerateGraphCode */
        long soap_type() const { return SOAP_TYPE___ns1__getOrGenerateGraphCode; }
        /** Constructor with member initializations */
        __ns1__getOrGenerateGraphCode() : ns1__getOrGenerateGraphCode_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getOrGenerateGraphCode * SOAP_FMAC2 soap_instantiate___ns1__getOrGenerateGraphCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1419 */
#ifndef SOAP_TYPE___ns1__setProcessingPlugins
#define SOAP_TYPE___ns1__setProcessingPlugins (81)
/* Wrapper: */
struct SOAP_CMAC __ns1__setProcessingPlugins {
      public:
        /** Optional element 'ns1:setProcessingPlugins' of XML schema type 'ns1:setProcessingPlugins' */
        ns1__setProcessingPlugins *ns1__setProcessingPlugins_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__setProcessingPlugins */
        long soap_type() const { return SOAP_TYPE___ns1__setProcessingPlugins; }
        /** Constructor with member initializations */
        __ns1__setProcessingPlugins() : ns1__setProcessingPlugins_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__setProcessingPlugins * SOAP_FMAC2 soap_instantiate___ns1__setProcessingPlugins(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1486 */
#ifndef SOAP_TYPE___ns1__getRecommendedAssets
#define SOAP_TYPE___ns1__getRecommendedAssets (85)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRecommendedAssets {
      public:
        /** Optional element 'ns1:getRecommendedAssets' of XML schema type 'ns1:getRecommendedAssets' */
        ns1__getRecommendedAssets *ns1__getRecommendedAssets_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRecommendedAssets */
        long soap_type() const { return SOAP_TYPE___ns1__getRecommendedAssets; }
        /** Constructor with member initializations */
        __ns1__getRecommendedAssets() : ns1__getRecommendedAssets_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRecommendedAssets * SOAP_FMAC2 soap_instantiate___ns1__getRecommendedAssets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1553 */
#ifndef SOAP_TYPE___ns1__getSimilarAssets
#define SOAP_TYPE___ns1__getSimilarAssets (89)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSimilarAssets {
      public:
        /** Optional element 'ns1:getSimilarAssets' of XML schema type 'ns1:getSimilarAssets' */
        ns1__getSimilarAssets *ns1__getSimilarAssets_;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSimilarAssets */
        long soap_type() const { return SOAP_TYPE___ns1__getSimilarAssets; }
        /** Constructor with member initializations */
        __ns1__getSimilarAssets() : ns1__getSimilarAssets_() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSimilarAssets * SOAP_FMAC2 soap_instantiate___ns1__getSimilarAssets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* gmafHeader:1656 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (90)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* gmafHeader:1656 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (91)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* gmafHeader:1656 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (93)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* gmafHeader:1656 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (96)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* gmafHeader:1656 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (97)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* gmafHeader:159 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (13)
typedef std::string xsd__anyURI;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (49)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (45)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (10)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (9)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (47)
#endif

/* ns1__getCollectionResponse has binding name 'ns1__getCollectionResponse' for type 'ns1:getCollectionResponse' */
#ifndef SOAP_TYPE_ns1__getCollectionResponse
#define SOAP_TYPE_ns1__getCollectionResponse (36)
#endif

/* ns1__getCollection has binding name 'ns1__getCollection' for type 'ns1:getCollection' */
#ifndef SOAP_TYPE_ns1__getCollection
#define SOAP_TYPE_ns1__getCollection (35)
#endif

/* ns1__processAssetFromFileResponse has binding name 'ns1__processAssetFromFileResponse' for type 'ns1:processAssetFromFileResponse' */
#ifndef SOAP_TYPE_ns1__processAssetFromFileResponse
#define SOAP_TYPE_ns1__processAssetFromFileResponse (34)
#endif

/* ns1__processAssetFromFile has binding name 'ns1__processAssetFromFile' for type 'ns1:processAssetFromFile' */
#ifndef SOAP_TYPE_ns1__processAssetFromFile
#define SOAP_TYPE_ns1__processAssetFromFile (33)
#endif

/* ns1__setProcessingPluginsResponse has binding name 'ns1__setProcessingPluginsResponse' for type 'ns1:setProcessingPluginsResponse' */
#ifndef SOAP_TYPE_ns1__setProcessingPluginsResponse
#define SOAP_TYPE_ns1__setProcessingPluginsResponse (32)
#endif

/* ns1__setProcessingPlugins has binding name 'ns1__setProcessingPlugins' for type 'ns1:setProcessingPlugins' */
#ifndef SOAP_TYPE_ns1__setProcessingPlugins
#define SOAP_TYPE_ns1__setProcessingPlugins (31)
#endif

/* ns1__processAssetFromBytesResponse has binding name 'ns1__processAssetFromBytesResponse' for type 'ns1:processAssetFromBytesResponse' */
#ifndef SOAP_TYPE_ns1__processAssetFromBytesResponse
#define SOAP_TYPE_ns1__processAssetFromBytesResponse (30)
#endif

/* ns1__processAssetFromBytes has binding name 'ns1__processAssetFromBytes' for type 'ns1:processAssetFromBytes' */
#ifndef SOAP_TYPE_ns1__processAssetFromBytes
#define SOAP_TYPE_ns1__processAssetFromBytes (29)
#endif

/* ns1__getAuthTokenResponse has binding name 'ns1__getAuthTokenResponse' for type 'ns1:getAuthTokenResponse' */
#ifndef SOAP_TYPE_ns1__getAuthTokenResponse
#define SOAP_TYPE_ns1__getAuthTokenResponse (28)
#endif

/* ns1__getAuthToken has binding name 'ns1__getAuthToken' for type 'ns1:getAuthToken' */
#ifndef SOAP_TYPE_ns1__getAuthToken
#define SOAP_TYPE_ns1__getAuthToken (27)
#endif

/* ns1__getRecommendedAssetsResponse has binding name 'ns1__getRecommendedAssetsResponse' for type 'ns1:getRecommendedAssetsResponse' */
#ifndef SOAP_TYPE_ns1__getRecommendedAssetsResponse
#define SOAP_TYPE_ns1__getRecommendedAssetsResponse (26)
#endif

/* ns1__getRecommendedAssets has binding name 'ns1__getRecommendedAssets' for type 'ns1:getRecommendedAssets' */
#ifndef SOAP_TYPE_ns1__getRecommendedAssets
#define SOAP_TYPE_ns1__getRecommendedAssets (25)
#endif

/* ns1__getSimilarAssetsResponse has binding name 'ns1__getSimilarAssetsResponse' for type 'ns1:getSimilarAssetsResponse' */
#ifndef SOAP_TYPE_ns1__getSimilarAssetsResponse
#define SOAP_TYPE_ns1__getSimilarAssetsResponse (24)
#endif

/* ns1__getSimilarAssets has binding name 'ns1__getSimilarAssets' for type 'ns1:getSimilarAssets' */
#ifndef SOAP_TYPE_ns1__getSimilarAssets
#define SOAP_TYPE_ns1__getSimilarAssets (23)
#endif

/* ns1__graphCode has binding name 'ns1__graphCode' for type 'ns1:graphCode' */
#ifndef SOAP_TYPE_ns1__graphCode
#define SOAP_TYPE_ns1__graphCode (22)
#endif

/* ns1__getOrGenerateGraphCodeResponse has binding name 'ns1__getOrGenerateGraphCodeResponse' for type 'ns1:getOrGenerateGraphCodeResponse' */
#ifndef SOAP_TYPE_ns1__getOrGenerateGraphCodeResponse
#define SOAP_TYPE_ns1__getOrGenerateGraphCodeResponse (21)
#endif

/* ns1__getOrGenerateGraphCode has binding name 'ns1__getOrGenerateGraphCode' for type 'ns1:getOrGenerateGraphCode' */
#ifndef SOAP_TYPE_ns1__getOrGenerateGraphCode
#define SOAP_TYPE_ns1__getOrGenerateGraphCode (20)
#endif

/* ns1__security has binding name 'ns1__security' for type 'ns1:security' */
#ifndef SOAP_TYPE_ns1__security
#define SOAP_TYPE_ns1__security (19)
#endif

/* ns1__generalMetadata has binding name 'ns1__generalMetadata' for type 'ns1:generalMetadata' */
#ifndef SOAP_TYPE_ns1__generalMetadata
#define SOAP_TYPE_ns1__generalMetadata (18)
#endif

/* ns1__node has binding name 'ns1__node' for type 'ns1:node' */
#ifndef SOAP_TYPE_ns1__node
#define SOAP_TYPE_ns1__node (17)
#endif

/* ns1__mmfg has binding name 'ns1__mmfg' for type 'ns1:mmfg' */
#ifndef SOAP_TYPE_ns1__mmfg
#define SOAP_TYPE_ns1__mmfg (16)
#endif

/* ns1__processAssetFromURLResponse has binding name 'ns1__processAssetFromURLResponse' for type 'ns1:processAssetFromURLResponse' */
#ifndef SOAP_TYPE_ns1__processAssetFromURLResponse
#define SOAP_TYPE_ns1__processAssetFromURLResponse (15)
#endif

/* ns1__processAssetFromURL has binding name 'ns1__processAssetFromURL' for type 'ns1:processAssetFromURL' */
#ifndef SOAP_TYPE_ns1__processAssetFromURL
#define SOAP_TYPE_ns1__processAssetFromURL (14)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (13)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (12)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (97)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (96)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (93)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (91)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (90)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (99)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (98)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (92)
#endif

/* ns1__getSimilarAssets * has binding name 'PointerTons1__getSimilarAssets' for type 'ns1:getSimilarAssets' */
#ifndef SOAP_TYPE_PointerTons1__getSimilarAssets
#define SOAP_TYPE_PointerTons1__getSimilarAssets (86)
#endif

/* ns1__getRecommendedAssets * has binding name 'PointerTons1__getRecommendedAssets' for type 'ns1:getRecommendedAssets' */
#ifndef SOAP_TYPE_PointerTons1__getRecommendedAssets
#define SOAP_TYPE_PointerTons1__getRecommendedAssets (82)
#endif

/* ns1__setProcessingPlugins * has binding name 'PointerTons1__setProcessingPlugins' for type 'ns1:setProcessingPlugins' */
#ifndef SOAP_TYPE_PointerTons1__setProcessingPlugins
#define SOAP_TYPE_PointerTons1__setProcessingPlugins (78)
#endif

/* ns1__getOrGenerateGraphCode * has binding name 'PointerTons1__getOrGenerateGraphCode' for type 'ns1:getOrGenerateGraphCode' */
#ifndef SOAP_TYPE_PointerTons1__getOrGenerateGraphCode
#define SOAP_TYPE_PointerTons1__getOrGenerateGraphCode (74)
#endif

/* ns1__processAssetFromURL * has binding name 'PointerTons1__processAssetFromURL' for type 'ns1:processAssetFromURL' */
#ifndef SOAP_TYPE_PointerTons1__processAssetFromURL
#define SOAP_TYPE_PointerTons1__processAssetFromURL (70)
#endif

/* ns1__processAssetFromBytes * has binding name 'PointerTons1__processAssetFromBytes' for type 'ns1:processAssetFromBytes' */
#ifndef SOAP_TYPE_PointerTons1__processAssetFromBytes
#define SOAP_TYPE_PointerTons1__processAssetFromBytes (66)
#endif

/* ns1__processAssetFromFile * has binding name 'PointerTons1__processAssetFromFile' for type 'ns1:processAssetFromFile' */
#ifndef SOAP_TYPE_PointerTons1__processAssetFromFile
#define SOAP_TYPE_PointerTons1__processAssetFromFile (62)
#endif

/* ns1__getCollection * has binding name 'PointerTons1__getCollection' for type 'ns1:getCollection' */
#ifndef SOAP_TYPE_PointerTons1__getCollection
#define SOAP_TYPE_PointerTons1__getCollection (58)
#endif

/* ns1__getAuthToken * has binding name 'PointerTons1__getAuthToken' for type 'ns1:getAuthToken' */
#ifndef SOAP_TYPE_PointerTons1__getAuthToken
#define SOAP_TYPE_PointerTons1__getAuthToken (54)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (53)
#endif

/* ns1__graphCode * has binding name 'PointerTons1__graphCode' for type 'ns1:graphCode' */
#ifndef SOAP_TYPE_PointerTons1__graphCode
#define SOAP_TYPE_PointerTons1__graphCode (50)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (48)
#endif

/* ns1__security * has binding name 'PointerTons1__security' for type 'ns1:security' */
#ifndef SOAP_TYPE_PointerTons1__security
#define SOAP_TYPE_PointerTons1__security (44)
#endif

/* ns1__generalMetadata * has binding name 'PointerTons1__generalMetadata' for type 'ns1:generalMetadata' */
#ifndef SOAP_TYPE_PointerTons1__generalMetadata
#define SOAP_TYPE_PointerTons1__generalMetadata (43)
#endif

/* ns1__node * has binding name 'PointerTons1__node' for type 'ns1:node' */
#ifndef SOAP_TYPE_PointerTons1__node
#define SOAP_TYPE_PointerTons1__node (41)
#endif

/* ns1__mmfg * has binding name 'PointerTons1__mmfg' for type 'ns1:mmfg' */
#ifndef SOAP_TYPE_PointerTons1__mmfg
#define SOAP_TYPE_PointerTons1__mmfg (40)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (38)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (37)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (11)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__mmfg *>  has binding name 'std__vectorTemplateOfPointerTons1__mmfg' for type 'ns1:mmfg' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__mmfg
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__mmfg (52)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (51)
#endif

/* std::vector<float>  has binding name 'std__vectorTemplateOffloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_std__vectorTemplateOffloat
#define SOAP_TYPE_std__vectorTemplateOffloat (46)
#endif

/* std::vector<ns1__node *>  has binding name 'std__vectorTemplateOfPointerTons1__node' for type 'ns1:node' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__node
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__node (42)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
